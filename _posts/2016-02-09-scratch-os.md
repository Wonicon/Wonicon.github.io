---
layout: post
title: 从零开始写操作系统遇到的坑
categories: 经验
tags: 编程 操作系统 计算机系统
---

虽然做过操作系统实验，但是那个实验充满了遗憾，比如文件系统和锁的概念没有得到实践。另外一点就是，那个实验是基于框架的，很多东西都为我们准备好了，尤其是页表管理模块。虽然方便而且有助于专注，但是也让我对一些细节缺少掌握。

目前准备从零做操作系统实验，虽然会参考现有的各种教学框架和实现，但是整个代码按道理应该是一个字符一个字符敲出来的。就算是照抄，只要不是无脑拷贝，就会出现一般开发中遇到的各种失误，而有选择的参考则会暴露自己设计时的思路缺陷，对于调试和思维的锻炼还是有的。

## boot loader

虽说要从零代码写起，不过 boot loader 我还是直接搬运了 [JOS](https://pdos.csail.mit.edu/6.828/2014/) 的代码，主要是想快点进入到内核代码的编写，毕竟 boot loader 和内核的代码不是一个位面的，我并不想一直盯着 BIOS 打转。不过我一开始的设想是 boot loader 做的很简单，只是单纯地拷贝内核代码。但是这要求内核代码有足够简单的结构，而准备这样的易于拷贝和硬编码的结构让我苦思许久。而 JOS 的做法则是复杂化 boot loader 的逻辑。除了基本的环境设置外，还要直接解析 ELF 文件进行内核代码的拷贝。这样内核的编译可以相对简化，硬编码文件位置也比编码代码位置要简单许多（所以其实脏活是链接器做了）。但是 boot loader 的大小就变得比较紧张了。

boot loader复杂话后，链接时需要增加些注意。 0x7C00 是首条指令的地址，对于可重定位的，有符号引用的模块间的编译链接，虽然我们能指定入口函数 entry point 和规定 .text 节的起始位置，但是稍加测试便可知这两者不能保证相等。一般情况下有 loader 准备环境，解析 EFL 文件找到 entry point，所以没什么问题。但是 boot loader 没有人来解析文件格式，必须保证 0x7C00 即是代码的起始也是逻辑的起始。这要保证入口符号是链接器见到的第一个重定位文件的第一个（有定义的）符号。所以在写 boot loader 的 makefile 时，一定要在某个层面上写死输入文件的顺序。

由于我在 64 位机器上编译，而内核目标是 32 位，所以一不小心忘记显式指明架构就导致了非常混乱的情况。总的来说是 boot loader 是 32 位的，并且解析的是 32 位的 ELF 文件，而独立编译的简单的“内核”代码则用了默认选项，导致生成了 64 位的 ELF 文件。这也就造成了 ELF 的魔数检查通过，但是 entry point 都能读错的情况。
