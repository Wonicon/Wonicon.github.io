---
layout: post
title: 从零开始写操作系统遇到的坑
categories: 经验
tags: 编程 操作系统 计算机系统
---

虽然做过操作系统实验，但是那个实验充满了遗憾，比如文件系统和锁的概念没有得到实践。另外一点就是，那个实验是基于框架的，很多东西都为我们准备好了，尤其是页表管理模块。虽然方便而且有助于专注，但是也让我对一些细节缺少掌握。

目前准备从零做操作系统实验，虽然会参考现有的各种教学框架和实现，但是整个代码按道理应该是一个字符一个字符敲出来的。就算是照抄，只要不是无脑拷贝，就会出现一般开发中遇到的各种失误，而有选择的参考则会暴露自己设计时的思路缺陷，对于调试和思维的锻炼还是有的。

## boot loader

虽说要从零代码写起，不过 boot loader 我还是直接搬运了 [JOS](https://pdos.csail.mit.edu/6.828/2014/) 的代码，主要是想快点进入到内核代码的编写，毕竟 boot loader 和内核的代码不是一个位面的，我并不想一直盯着 BIOS 打转。不过我一开始的设想是 boot loader 做的很简单，只是单纯地拷贝内核代码。但是这要求内核代码有足够简单的结构，而准备这样的易于拷贝和硬编码的结构让我苦思许久。而 JOS 的做法则是复杂化 boot loader 的逻辑。除了基本的环境设置外，还要直接解析 ELF 文件进行内核代码的拷贝。这样内核的编译可以相对简化，硬编码文件位置也比编码代码位置要简单许多（所以其实脏活是链接器做了）。但是 boot loader 的大小就变得比较紧张了。

boot loader复杂话后，链接时需要增加些注意。 0x7C00 是首条指令的地址，对于可重定位的，有符号引用的模块间的编译链接，虽然我们能指定入口函数 entry point 和规定 .text 节的起始位置，但是稍加测试便可知这两者不能保证相等。一般情况下有 loader 准备环境，解析 EFL 文件找到 entry point，所以没什么问题。但是 boot loader 没有人来解析文件格式，必须保证 0x7C00 即是代码的起始也是逻辑的起始。这要保证入口符号是链接器见到的第一个重定位文件的第一个（有定义的）符号。所以在写 boot loader 的 makefile 时，一定要在某个层面上写死输入文件的顺序。

由于我在 64 位机器上编译，而内核目标是 32 位，所以一不小心忘记显式指明架构就导致了非常混乱的情况。总的来说是 boot loader 是 32 位的，并且解析的是 32 位的 ELF 文件，而独立编译的简单的“内核”代码则用了默认选项，导致生成了 64 位的 ELF 文件。这也就造成了 ELF 的魔数检查通过，但是 entry point 都能读错的情况。

## 链接

为了省去书写格式化字符串的功夫，我暂时拷贝了 JOS 的 lib 目录下的代码，除去暂时不用的 console.c。但是编译链接时出现了一些小问题。

由于格式化函数里有对`long long`类型的数进行处理，在`-m32`的编译选项下，会生成`__udiv3di3`等一系列软件模拟 64 位数运算的函数。令我感到奇怪的是，明明已经使用`-fno-builtin`回避内置函数了，为什么还会夹带编译器的私货？然后我发现我使用的标准是`-std=gnu11`，如果改成`-std=c11`，那么可能不会生成`__udiv3di3`这样的函数，不过内联汇编的关键字就需要加下划线了。

我参考了 JOS 的 Makefile 的解决办法，发现他们在链接时还是额外加上了 gcc 的库。gcc 的选项`-print-libgcc-file-name`可以打印标准库的归档文件的路径，加上对应的编译选项能输出对应的归档文件（主要是`-m32`的影响）。

## 串口输出

在 QEMU 下，通过串口将内核的调试信息输出到标准输出上是极好的一件事。串口输出作为一个基本的工具，一般在实验框架中是提供好的，但是还是要知道怎么从已有的资料中明确串口的使用方法并编码实现，[OSDev 的 Serial Ports 条目](http://wiki.osdev.org/Serial_Ports)的内容已经足够了。

一个关键的问题是，用`-serial stdio`作为 qemu 的启动选项后，内核代码访问哪些个端口去进行串口设备所规定的操作。根据上面那个 OSDev 的链接，一共有四个串口：COM1、COM2、COM3 和 COM4，其提供的 4 个起始端口号在 qemu 下是正确可用的：

|COM Port|IO Port|
|--------|-------|
|COM1|3F8h|
|COM2|2F8h|
|COM3|3E8h|
|COM4|2E8h|

更加保险的做法是扫面BIOS Data Area，从地址 0x4000 开始的 4 个连续的 16 位数记录了从 COM1 到 COM4 这四个串口的起始端口号（[OSDev 上的参考内容](http://wiki.osdev.org/Memory_Map_(x86)#BIOS_Data_Area_.28BDA.29)）。

要想使用全部 4 个串口，只需要设置多个`-serial dev`作为 qemu 的启动选项（详见 [qemu 的文档](http://wiki.qemu.org/download/qemu-doc.html)，搜索`-serial dev`快速定位），比如`-serial stdio -serial file:foo -serial file:bar`就会将标准输入输出作为 COM1，文件 foo 和 bar 分别作为 COM2 和 COM3。
